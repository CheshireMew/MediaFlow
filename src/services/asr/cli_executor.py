from pathlib import Path
from typing import List, Optional
import subprocess
import os
import re
import time
import shutil
from loguru import logger
from src.config import settings
from src.models.schemas import SubtitleSegment
from src.utils.subtitle_manager import SubtitleManager

class CLIExecutor:
    def __init__(self, model_manager):
        self.model_manager = model_manager

    def transcribe(self, audio_path: str, model_name: str, language: str, initial_prompt: str, progress_callback) -> List[SubtitleSegment]:
        """
        Use Independent Faster-Whisper-XXL CLI for transcription.
        """
        if not Path(settings.FASTER_WHISPER_CLI_PATH).exists():
            raise FileNotFoundError(f"Faster Whisper CLI not found at: {settings.FASTER_WHISPER_CLI_PATH}")
            
        logger.info(f"Using Faster-Whisper-XXL CLI: {settings.FASTER_WHISPER_CLI_PATH}")
        
        # Temp output directory
        output_dir = settings.TEMP_DIR / f"cli_out_{Path(audio_path).stem}_{int(time.time())}"
        output_dir.mkdir(parents=True, exist_ok=True)

        # Ensure model is downloaded first
        local_model_path = self.model_manager.ensure_model_downloaded(model_name, progress_callback)
        
        # Determine CLI model argument
        cli_model = self._resolve_cli_model_arg(model_name, local_model_path)
        
        # Build Command
        cmd = self._build_command(audio_path, cli_model, output_dir, language, initial_prompt)
        
        logger.info(f"CLI Command: {' '.join(cmd)}")
        if progress_callback: progress_callback(10, "Starting Faster-Whisper CLI processing...")
        
        try:
            self._execute_subprocess(cmd, progress_callback)
            
            # Find output SRT
            srt_files = list(output_dir.glob("*.srt"))
            if not srt_files:
                raise RuntimeError("No SRT output generated by CLI")
            
            srt_path = srt_files[0]
            content = srt_path.read_text(encoding='utf-8')
            return SubtitleManager.parse_srt(content)
            
        finally:
            # Cleanup
            try:
                if output_dir.exists():
                    shutil.rmtree(output_dir, ignore_errors=True)
            except Exception as e:
                logger.warning(f"Failed to clean up temp dir {output_dir}: {e}")

    def _resolve_cli_model_arg(self, model_name: str, local_model_path: str) -> str:
        # CLI expects just the model size name if using --model_dir
        if Path(local_model_path).exists():
            if "large-v3" in model_name: return "large-v3"
            elif "large-v2" in model_name: return "large-v2"
            elif "medium" in model_name: return "medium"
            elif "small" in model_name: return "small"
            elif "base" in model_name: return "base"
            elif "tiny" in model_name: return "tiny"
        return model_name

    def _build_command(self, audio_path: str, cli_model: str, output_dir: Path, language: str, initial_prompt: str) -> List[str]:
        # Language specific settings
        is_cjk = language in ["zh", "ja", "ko", "zh-CN"]
        max_line_width = "30" if is_cjk else "50"
        
        cmd = [
            settings.FASTER_WHISPER_CLI_PATH,
            str(audio_path),
            "--model", str(cli_model),
            "-o", str(output_dir),
            "--output_format", "srt",
            "--print_progress",
            "--vad_filter", "True",
            "--sentence", 
            "--max_line_width", max_line_width,
            "--max_line_count", "1",
            "--max_comma", "20",
            "--max_comma_cent", "50"
        ]
        
        if language and language != "auto":
            cmd.extend(["--language", language])
        
        if initial_prompt:
             cmd.extend(["--initial_prompt", initial_prompt])
             
        # Use existing model dir
        cli_model_dir = settings.MODEL_DIR / "faster-whisper"
        cli_model_dir.mkdir(parents=True, exist_ok=True)
        cmd.extend(["--model_dir", str(cli_model_dir)])
        
        return cmd

    def _execute_subprocess(self, cmd: List[str], progress_callback):
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding='utf-8',
            errors='replace',
            creationflags=subprocess.CREATE_NO_WINDOW if os.name == 'nt' else 0
        )
        
        while True:
            line = process.stdout.readline()
            if not line and process.poll() is not None:
                break
            if line:
                line = line.strip()
                if match := re.search(r"(\d+)%", line):
                    p = int(match.group(1))
                    if "MB" not in line and "kB" not in line and progress_callback: 
                        progress_callback(10 + int(p * 0.8), f"Transcribing... {p}%")
                
                if not any(x in line for x in ["model.bin", ".json", "MB/s", "kB/s", "it/s"]) and line.strip():
                    logger.debug(f"CLI: {line}")
        
        if process.returncode != 0:
            raise RuntimeError(f"CLI process failed with code {process.returncode}")
